{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}"
    },
    "contracts/MarginBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./utils/MinimalProxyable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IAddressResolver.sol\";\nimport \"./interfaces/IFuturesMarket.sol\";\nimport \"./interfaces/IFuturesMarketManager.sol\";\n\n/// @title Kwenta MarginBase Account\n/// @author JaredBorders and JChiaramonte7\n/// @notice Flexible, minimalist, and gas-optimized cross-margin enabled account\n/// for managing perpetual futures positions\ncontract MarginBase is MinimalProxyable {\n    /*///////////////////////////////////////////////////////////////\n                                Constants\n    ///////////////////////////////////////////////////////////////*/\n\n    // tracking code used when modifying positions\n    bytes32 private constant TRACKING_CODE = \"KWENTA\";\n\n    // name for futures market manager, needed for fetching market key\n    bytes32 private constant FUTURES_MANAGER = \"FuturesMarketManager\";\n\n    /*///////////////////////////////////////////////////////////////\n                                Types\n    ///////////////////////////////////////////////////////////////*/\n\n    // marketKey: synthetix futures market id/key\n    // margin: amount of margin (in sUSD) in specific futures market\n    // size: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    struct ActiveMarketPosition {\n        bytes32 marketKey;\n        uint128 margin;\n        int128 size;\n    }\n\n    // marketKey: synthetix futures market id/key\n    // marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    // sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    // isClosing: indicates if position needs to be closed\n    struct UpdateMarketPositionSpec {\n        bytes32 marketKey;\n        int256 marginDelta; // positive indicates deposit, negative withdraw\n        int256 sizeDelta;\n        bool isClosing; // if true, marginDelta nor sizeDelta are considered. simply closes position\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                State\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice synthetix address resolver\n    IAddressResolver private addressResolver;\n\n    /// @notice synthetix futures market manager\n    IFuturesMarketManager private futuresManager;\n\n    /// @notice token contract used for account margin\n    IERC20 public marginAsset;\n\n    /// @notice market keys that the account has active positions in\n    bytes32[] public activeMarketKeys;\n\n    /// @notice market keys mapped to active market positions\n    mapping(bytes32 => ActiveMarketPosition) public activeMarketPositions;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted after a successful deposit\n    /// @param user: the address that deposited into account\n    /// @param amount: amount of marginAsset to deposit into marginBase account\n    event Deposit(address indexed user, uint256 amount);\n\n    /// @notice emitted after a successful withdrawal\n    /// @param user: the address that withdrew from account\n    /// @param amount: amount of marginAsset to withdraw from marginBase account\n    event Withdraw(address indexed user, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                                Errors\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice amount deposited/withdrawn into/from account cannot be zero\n    error AmountCantBeZero();\n\n    /// @notice position with given marketKey does not exist\n    /// @param marketKey: key for synthetix futures market\n    error MissingMarketKey(bytes32 marketKey);\n\n    /// @notice limit size of new position specs passed into distribute margin\n    /// @param numberOfNewPositions: number of new position specs\n    error MaxNewPositionsExceeded(uint256 numberOfNewPositions);\n\n    /// @notice market withdrawal size was positive (i.e. deposit)\n    /// @param withdrawalSize: amount of margin asset to withdraw from market\n    error InvalidMarketWithdrawSize(int256 withdrawalSize);\n\n    /// @notice market deposit size was negative (i.e. withdraw)\n    /// @param depositSize: amount of margin asset to deposit into market\n    error InvalidMarketDepositSize(int256 depositSize);\n\n    /*///////////////////////////////////////////////////////////////\n                        Constructor & Initializer\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice constructor never used except for first CREATE\n    // solhint-disable-next-line\n    constructor() MinimalProxyable() {}\n\n    /// @notice initialize contract (only once) and transfer ownership to caller\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    function initialize(address _marginAsset, address _addressResolver)\n        external\n        initOnce\n    {\n        addressResolver = IAddressResolver(_addressResolver);\n        futuresManager = IFuturesMarketManager(\n            addressResolver.requireAndGetAddress(\n                FUTURES_MANAGER,\n                \"MarginBase: Could not get Futures Market Manager\"\n            )\n        );\n        marginAsset = IERC20(_marginAsset);\n\n        /// @dev the Ownable constructor is never called when we create minimal proxies\n        _transferOwnership(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Views\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice get number of active market positions account has\n    /// @return number of positions which are currently active for account\n    function getNumberOfActivePositions() external view returns (uint256) {\n        return activeMarketKeys.length;\n    }\n\n    /// @notice get all active market positions\n    /// @return positions which are currently active for account (ActiveMarketPosition structs)\n    function getAllActiveMarketPositions()\n        external\n        view\n        returns (ActiveMarketPosition[] memory)\n    {\n        ActiveMarketPosition[] memory positions = new ActiveMarketPosition[](\n            activeMarketKeys.length\n        );\n        for (uint16 i = 0; i < activeMarketKeys.length; i++) {\n            positions[i] = (activeMarketPositions[activeMarketKeys[i]]);\n        }\n        return positions;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Account Deposit & Withdraw\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @param _amount: amount of marginAsset to deposit into marginBase account\n    function deposit(uint256 _amount)\n        external\n        onlyOwner\n    {   \n        /// @notice amount deposited into account cannot be zero\n        if (_amount == 0) {\n            revert AmountCantBeZero();\n        }\n\n        // transfer in margin asset from user\n        // (will revert if user does not have amount specified)\n        require(\n            marginAsset.transferFrom(owner(), address(this), _amount),\n            \"MarginBase: deposit failed\"\n        );\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @param _amount: amount of marginAsset to withdraw from marginBase account\n    function withdraw(uint256 _amount)\n        external\n        onlyOwner\n    {\n        /// @notice amount withdrawn from account cannot be zero\n        if (_amount == 0) {\n            revert AmountCantBeZero();\n        }\n\n        // transfer out margin asset to user\n        // (will revert if account does not have amount specified)\n        require(\n            marginAsset.transfer(owner(), _amount),\n            \"MarginBase: withdraw failed\"\n        );\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Margin Distribution\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice distribute margin across all/some positions specified via _newPositions\n    /// @dev _newPositions may contain any number of new or existing positions\n    /// @dev caller can close and withdraw all margin from position if _newPositions[i].isClosing is true\n    /// @param _newPositions: an array of UpdateMarketPositionSpec's used to modify active market positions\n    function distributeMargin(UpdateMarketPositionSpec[] calldata _newPositions)\n        external\n        onlyOwner\n    {\n        /// @notice limit size of new position specs passed into distribute margin\n        if (_newPositions.length > type(uint16).max) {\n            revert MaxNewPositionsExceeded(_newPositions.length);\n        }\n\n        // for each new position in _newPositions, distribute margin accordingly and update state\n        for (uint16 i = 0; i < _newPositions.length; i++) {\n            if (_newPositions[i].isClosing) {\n                /// @notice close position and transfer margin back to account\n                closePositionAndWithdraw(_newPositions[i].marketKey);\n            } else if (_newPositions[i].marginDelta < 0) {\n                /// @notice remove margin from market and potentially adjust size\n                modifyPositionForMarketAndWithdraw(\n                    _newPositions[i].marginDelta,\n                    _newPositions[i].sizeDelta,\n                    _newPositions[i].marketKey\n                );\n            } else {\n                /// @dev marginDelta >= 0\n                /// @notice deposit margin into market and potentially adjust size\n                depositAndModifyPositionForMarket(\n                    _newPositions[i].marginDelta,\n                    _newPositions[i].sizeDelta,\n                    _newPositions[i].marketKey\n                );\n                // if marginDelta is 0, there will simply be NO additional\n                // margin deposited into the market\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Internal Margin Distribution\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice deposit margin into specific market, creating/adding to a position\n    /// @param _depositSize: size of deposit in sUSD\n    /// @param _sizeDelta: size and position type (long//short) denoted in market synth (ex: sETH)\n    /// @param _marketKey: synthetix futures market id/key\n    function depositAndModifyPositionForMarket(\n        int256 _depositSize,\n        int256 _sizeDelta,\n        bytes32 _marketKey\n    ) internal {\n        // _depositSize must be positive or zero (i.e. not a withdraw)\n        if (_depositSize < 0) {\n            revert InvalidMarketDepositSize(_depositSize);\n        }\n\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        /// @notice alter the amount of margin in specific market position\n        /// @dev positive input triggers a deposit; a negative one, a withdrawal\n        market.transferMargin(_depositSize);\n\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // modify position in specific market with KWENTA tracking code\n            market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n        }\n\n        // fetch new position data from Synthetix\n        (, , uint128 margin, , int128 size) = market.positions(address(this));\n\n        // update state for given open market position\n        updateActiveMarketPosition(_marketKey, margin, size, market);\n    }\n\n    /// @notice modify active position and withdraw marginAsset from market into this account\n    /// @param _withdrawalSize: size of sUSD to withdraw from market into account\n    /// @param _sizeDelta: size and position type (long//short) denoted in market synth (ex: sETH)\n    /// @param _marketKey: synthetix futures market id/key\n    function modifyPositionForMarketAndWithdraw(\n        int256 _withdrawalSize,\n        int256 _sizeDelta,\n        bytes32 _marketKey\n    ) internal {\n        // _withdrawalSize must be negative or zero (i.e. not a deposit)\n        if (_withdrawalSize > 0) {\n            revert InvalidMarketWithdrawSize(_withdrawalSize);\n        }\n\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // modify position in specific market with KWENTA tracking code\n            market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n        }\n\n        /// @notice alter the amount of margin in specific market position\n        /// @dev positive input triggers a deposit; a negative one, a withdrawal\n        market.transferMargin(_withdrawalSize);\n\n        // fetch new position data from Synthetix\n        (, , uint128 margin, , int128 size) = market.positions(address(this));\n\n        // update state for given open market position\n        updateActiveMarketPosition(_marketKey, margin, size, market);\n    }\n\n    /// @notice closes futures position and withdraws all margin in that market back to this account\n    /// @param _marketKey: synthetix futures market id/key\n    function closePositionAndWithdraw(bytes32 _marketKey) internal {\n        // update state (remove market)\n        removeActiveMarketPositon(_marketKey);\n\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        // close market position\n        market.closePosition();\n\n        // withdraw margin back to this account\n        market.withdrawAllMargin();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Internal Account State Management\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice used internally to update contract state for the account's active position tracking\n    /// @param _marketKey: key for synthetix futures market\n    /// @param _margin: amount of margin the specific market position has\n    /// @param _size: represents size of position (i.e. accounts for leverage)\n    /// @dev if _size becomes 0, remove position from account state and withdraw margin\n    function updateActiveMarketPosition(\n        bytes32 _marketKey,\n        uint128 _margin,\n        int128 _size,\n        IFuturesMarket market\n    ) internal {\n        // if position size is 0, position is effectively closed on\n        // FuturesMarket but margin is still in contract, thus it must\n        // be withdrawn back to this account\n        if (_size == 0) {\n            // update state (remove market)\n            removeActiveMarketPositon(_marketKey);\n\n            // withdraw margin back to this account\n            market.withdrawAllMargin();\n            return;\n        }\n\n        ActiveMarketPosition memory newPosition = ActiveMarketPosition(\n            _marketKey,\n            _margin,\n            _size\n        );\n\n        // check if this is updating a position or creating one\n        if (activeMarketPositions[_marketKey].marketKey == 0) {\n            activeMarketKeys.push(_marketKey);\n        }\n\n        // update state of active market positions\n        activeMarketPositions[_marketKey] = newPosition;\n    }\n\n    /// @notice used internally to remove active market position from contract's internal state\n    /// @param _marketKey: key for previously active market position\n    function removeActiveMarketPositon(bytes32 _marketKey) internal {\n        // ensure active market exists\n        if (activeMarketPositions[_marketKey].marketKey == 0) {\n            revert MissingMarketKey(_marketKey);\n        }\n\n        delete activeMarketPositions[_marketKey];\n        uint256 numberOfActiveMarkets = activeMarketKeys.length;\n\n        for (uint16 i = 0; i < numberOfActiveMarkets; i++) {\n            // once _marketKey is encountered, swap with\n            // last element in array and exit for-loop\n            if (activeMarketKeys[i] == _marketKey) {\n                activeMarketKeys[i] = activeMarketKeys[\n                    numberOfActiveMarkets - 1\n                ];\n                break;\n            }\n        }\n        // remove last element (which will be _marketKey)\n        activeMarketKeys.pop();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                Internal Futures Market Initialization\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice addressResolver fetches IFuturesMarket address for specific market\n    /// @param _marketKey: key for synthetix futures market\n    /// @return IFuturesMarket contract interface\n    function futuresMarket(bytes32 _marketKey)\n        internal\n        view\n        returns (IFuturesMarket)\n    {\n        return IFuturesMarket(futuresManager.marketForKey(_marketKey));\n    }\n}\n"
    },
    "contracts/utils/MinimalProxyable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MinimalProxyable is Ownable {\n\n    bool masterCopy;\n    bool initialized;\n\n    constructor() {\n        masterCopy = true;\n    }\n\n    function initialize() public initOnce {}\n\n    modifier initOnce {\n        require(!masterCopy, \"Cannot initialize implementation\");\n        require(!initialized, \"Already initialized\");\n        initialized = true;\n        _;\n    }\n\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IFuturesMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./IFuturesMarketBaseTypes.sol\";\n\ninterface IFuturesMarket {\n    /* ========== FUNCTION INTERFACE ========== */\n\n    /* ---------- Market Details ---------- */\n\n    function marketKey() external view returns (bytes32 key);\n\n    function baseAsset() external view returns (bytes32 key);\n\n    function marketSize() external view returns (uint128 size);\n\n    function marketSkew() external view returns (int128 skew);\n\n    function fundingLastRecomputed() external view returns (uint32 timestamp);\n\n    function fundingSequence(uint index) external view returns (int128 netFunding);\n\n    function positions(address account)\n        external\n        view\n        returns (\n            uint64 id,\n            uint64 fundingIndex,\n            uint128 margin,\n            uint128 lastPrice,\n            int128 size\n        );\n\n    function assetPrice() external view returns (uint price, bool invalid);\n\n    function marketSizes() external view returns (uint long, uint short);\n\n    function marketDebt() external view returns (uint debt, bool isInvalid);\n\n    function currentFundingRate() external view returns (int fundingRate);\n\n    function unrecordedFunding() external view returns (int funding, bool invalid);\n\n    function fundingSequenceLength() external view returns (uint length);\n\n    /* ---------- Position Details ---------- */\n\n    function notionalValue(address account) external view returns (int value, bool invalid);\n\n    function profitLoss(address account) external view returns (int pnl, bool invalid);\n\n    function accruedFunding(address account) external view returns (int funding, bool invalid);\n\n    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid);\n\n    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid);\n\n    function liquidationPrice(address account) external view returns (uint price, bool invalid);\n\n    function liquidationFee(address account) external view returns (uint);\n\n    function canLiquidate(address account) external view returns (bool);\n\n    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid);\n\n    function postTradeDetails(int sizeDelta, address sender)\n        external\n        view\n        returns (\n            uint margin,\n            int size,\n            uint price,\n            uint liqPrice,\n            uint fee,\n            IFuturesMarketBaseTypes.Status status\n        );\n\n    /* ---------- Market Operations ---------- */\n\n    function recomputeFunding() external returns (uint lastIndex);\n\n    function transferMargin(int marginDelta) external;\n\n    function withdrawAllMargin() external;\n\n    function modifyPosition(int sizeDelta) external;\n\n    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function submitNextPriceOrder(int sizeDelta) external;\n\n    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function cancelNextPriceOrder(address account) external;\n\n    function executeNextPriceOrder(address account) external;\n\n    function closePosition() external;\n\n    function closePositionWithTracking(bytes32 trackingCode) external;\n\n    function liquidatePosition(address account) external;\n}\n"
    },
    "contracts/interfaces/IFuturesMarketManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ninterface IFuturesMarketManager {\n    function markets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMarkets() external view returns (uint);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function marketForKey(bytes32 marketKey) external view returns (address);\n\n    function marketsForKeys(bytes32[] calldata marketKeys) external view returns (address[] memory);\n\n    function totalDebt() external view returns (uint debt, bool isInvalid);\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IFuturesMarketBaseTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ninterface IFuturesMarketBaseTypes {\n    /* ========== TYPES ========== */\n\n    enum Status {\n        Ok,\n        InvalidPrice,\n        PriceOutOfBounds,\n        CanLiquidate,\n        CannotLiquidate,\n        MaxMarketSizeExceeded,\n        MaxLeverageExceeded,\n        InsufficientMargin,\n        NotPermitted,\n        NilOrder,\n        NoPositionOpen,\n        PriceTooVolatile\n    }\n\n    // If margin/size are positive, the position is long; if negative then it is short.\n    struct Position {\n        uint64 id;\n        uint64 lastFundingIndex;\n        uint128 margin;\n        uint128 lastPrice;\n        int128 size;\n    }\n\n    // next-price order storage\n    struct NextPriceOrder {\n        int128 sizeDelta; // difference in position to pass to modifyPosition\n        uint128 targetRoundId; // price oracle roundId using which price this order needs to exucted\n        uint128 commitDeposit; // the commitDeposit paid upon submitting that needs to be refunded if order succeeds\n        uint128 keeperDeposit; // the keeperDeposit paid upon submitting that needs to be paid / refunded on tx confirmation\n        bytes32 trackingCode; // tracking code to emit on execution for volume source fee sharing\n    }\n}\n"
    },
    "contracts/MarginAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./utils/MinimalProxyFactory.sol\";\nimport \"./MarginBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Kwenta MarginBase Factory\n/// @author JaredBorders and JChiaramonte7\n/// @notice Factory which enables deploying a MarginBase account for any user \ncontract MarginAccountFactory is MinimalProxyFactory {\n    \n    string public version; // format: (0.1.0)\n\n    /*///////////////////////////////////////////////////////////////\n                                Immutables\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice MarginBase contract acting as user's account\n    MarginBase public immutable implementation;\n\n    /// @notice ERC20 token used to interact with markets\n    IERC20 public immutable marginAsset;\n\n    /// @notice synthetix address resolver\n    address public immutable addressResolver;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    event NewAccount(address indexed owner, address account);\n\n    /*///////////////////////////////////////////////////////////////\n                                Constructor\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice deploy MarginBase implementation to later be cloned\n    /// @param _version: version of contract\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    constructor(\n        string memory _version,\n        address _marginAsset,\n        address _addressResolver\n    ) {\n        version = _version;\n        implementation = new MarginBase();\n        marginAsset = IERC20(_marginAsset);\n        addressResolver = _addressResolver;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Account Deployment\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice clone MarginBase (i.e. create new account for user)\n    /// @dev this contract is the initial owner of cloned MarginBase,\n    /// but ownership is transferred after successful initialization\n    function newAccount() external returns (address) {\n        MarginBase account = MarginBase(\n            _cloneAsMinimalProxy(address(implementation), \"Creation failure\")\n        );\n        account.initialize(address(marginAsset), addressResolver);\n        account.transferOwnership(msg.sender);\n\n        emit NewAccount(msg.sender, address(account));\n        return address(account);\n    }\n}\n"
    },
    "contracts/utils/MinimalProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ncontract MinimalProxyFactory {\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg)\n        internal\n        returns (address clone)\n    {\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\n\n        assembly {\n            clone := create(\n                0, // no value\n                add(createData, 0x20), // data\n                55 // data is always 55 bytes (10 constructor + 45 code)\n            )\n        }\n\n        // If CREATE fails for some reason, address(0) is returned\n        require(clone != address(0), _revertMsg);\n    }\n\n    function _generateMinimalProxyCreateData(address _base)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                //---- constructor -----\n                bytes10(0x3d602d80600a3d3981f3),\n                //---- proxy code -----\n                bytes10(0x363d3d373d3d3d363d73),\n                _base,\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\n            );\n    }\n}"
    },
    "contracts/interfaces/ISynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}